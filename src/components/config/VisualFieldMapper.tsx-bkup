// src/components/config/VisualFieldMapper.tsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';
import {
  Box, Typography, Button, CircularProgress, Alert,
  Paper, Divider, Card, CardContent, TextField, Chip, IconButton, Tooltip
} from '@mui/material';
import SearchIcon from '@mui/icons-material/Search';
import HelpOutlineIcon from '@mui/icons-material/HelpOutline';
import RefreshIcon from '@mui/icons-material/Refresh';
import { APP_FIELDS } from './ApiMappingBuilder';

interface VisualFieldMapperProps {
  appFields: Record<string, any>;
  apiEndpoint: string;
  currentMapping: Record<string, any>;
  onMappingChange: (mapping: Record<string, any>) => void;
}

const VisualFieldMapper: React.FC<VisualFieldMapperProps> = ({
  appFields,
  apiEndpoint,
  currentMapping,
  onMappingChange
}) => {
  const [sampleData, setSampleData] = useState<any>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [flattenedApiFields, setFlattenedApiFields] = useState<string[]>([]);
  const [selectedAppField, setSelectedAppField] = useState<string | null>(null);
  const [apiFieldFilter, setApiFieldFilter] = useState('');
  const [previewData, setPreviewData] = useState<any>(null);
  const [showTutorial, setShowTutorial] = useState(false);
  
  // When currentMapping changes externally, update preview
  useEffect(() => {
    if (sampleData && currentMapping) {
      updatePreview(sampleData, currentMapping);
    }
  }, [currentMapping, sampleData]);
  
  // Fetch sample data from API
  const fetchSampleData = async () => {
    if (!apiEndpoint) {
      setError('Please configure API endpoint in Settings before fetching sample data');
      return;
    }
    
    setLoading(true);
    setError(null);
    
    try {
      // Ensure endpoint ends with /api
      const baseEndpoint = apiEndpoint.endsWith('/api') 
        ? apiEndpoint 
        : `${apiEndpoint}/api`;
      
      // Adjust the endpoint to match the API's submissions endpoint
      const url = `${baseEndpoint}/submissions`;
      const response = await axios.get(url);
      
      if (response.data && Array.isArray(response.data) && response.data.length > 0) {
        // Use the first item as sample data
        setSampleData(response.data[0]);
        
        // Flatten the API data structure into dot notation paths
        const fields = flattenObject(response.data[0]);
        setFlattenedApiFields(Object.keys(fields));
        
        // Generate preview based on current mapping
        updatePreview(response.data[0], currentMapping);
      } else {
        setError('No valid data received from API');
      }
    } catch (error) {
      console.error('Error fetching sample data:', error);
      setError(`Failed to fetch sample data: ${error instanceof Error ? error.message : String(error)}`);
      
      // If in development, provide a mock sample for testing
      if (process.env.NODE_ENV === 'development') {
        const mockSample = {
          id: "SUB-12345",
          created_at: "2023-05-15",
          status: "In Review",
          broker: {
            company_name: "ABC Insurance",
            email_address: "contact@abc.com"
          },
          insured: {
            legal_name: "Acme Corp",
            sic_code: "1234",
            industry_description: "Manufacturing",
            address: {
              line1: "123 Main St",
              city: "Boston",
              state: "MA",
              postal_code: "02108"
            },
            years_in_business: 15,
            employee_count: 250
          },
          submission: {
            coverage_lines: ["General Liability", "Property"],
            effective_date: "2023-06-01",
            expiration_date: "2024-06-01"
          },
          documents: [
            { id: "DOC-1", name: "Application", type: "Application Form", status: "Processed" }
          ]
        };
        
        setSampleData(mockSample);
        const fields = flattenObject(mockSample);
        setFlattenedApiFields(Object.keys(fields));
        updatePreview(mockSample, currentMapping);
        setError('Using mock data for demonstration. Connect to a real API for production use.');
      }
    } finally {
      setLoading(false);
    }
  };
  
  // Flatten nested object into dot notation
  const flattenObject = (obj: any, prefix = ''): Record<string, any> => {
    return Object.keys(obj).reduce((acc: Record<string, any>, key: string) => {
      const pre = prefix.length ? `${prefix}.` : '';
      
      if (
        typeof obj[key] === 'object' && 
        obj[key] !== null && 
        !Array.isArray(obj[key])
      ) {
        Object.assign(acc, flattenObject(obj[key], `${pre}${key}`));
      } else {
        acc[`${pre}${key}`] = obj[key];
      }
      
      return acc;
    }, {});
  };
  
  // Get nested value from object using dot notation
  const getValueFromPath = (obj: any, path: string): any => {
    if (!obj || !path) return undefined;
    
    return path.split('.').reduce((prev, curr) => {
      return prev && prev[curr] !== undefined ? prev[curr] : undefined;
    }, obj);
  };
  
  // Update preview data based on mapping
  const updatePreview = (data: any, mapping: Record<string, any>) => {
    if (!data || !mapping) return;
    
    const result: Record<string, any> = {};
    
    const applyMapping = (targetObj: any, mappingObj: any) => {
      Object.entries(mappingObj).forEach(([key, value]) => {
        if (typeof value === 'object' && value !== null) {
          targetObj[key] = {};
          applyMapping(targetObj[key], value);
        } else if (typeof value === 'string' && value) {
          targetObj[key] = getValueFromPath(data, value);
        }
      });
    };
    
    applyMapping(result, mapping);
    setPreviewData(result);
  };
  
  // Get current mapping value for a field path
  const getMappingForPath = (path: string): string => {
    if (!path) return '';
    
    const segments = path.split('.');
    let current = currentMapping;
    
    for (let i = 0; i < segments.length; i++) {
      if (!current[segments[i]]) return '';
      
      if (i === segments.length - 1) {
        return typeof current[segments[i]] === 'string' ? current[segments[i]] : '';
      }
      
      current = current[segments[i]];
    }
    
    return '';
  };
  
  // Handle mapping change
  const handleMapField = (appField: string, apiField: string) => {
    if (!appField) return;
    
    // Create a deep copy of the current mapping
    const newMapping = JSON.parse(JSON.stringify(currentMapping));
    
    // Split the app field path into segments
    const fieldPath = appField.split('.');
    
    // Navigate to the right location in the mapping object
    let current = newMapping;
    for (let i = 0; i < fieldPath.length - 1; i++) {
      if (!current[fieldPath[i]]) {
        current[fieldPath[i]] = {};
      }
      current = current[fieldPath[i]];
    }
    
    // Set the mapping value
    current[fieldPath[fieldPath.length - 1]] = apiField;
    
    // Update the mapping
    onMappingChange(newMapping);
    
    // Update preview
    if (sampleData) {
      updatePreview(sampleData, newMapping);
    }
    
    // Clear selection
    setSelectedAppField(null);
  };
  
  // Validate mapping completeness
  const validateMapping = (): { 
    valid: boolean; 
    missingRequired: string[]; 
    incorrectTypes: Array<{field: string, expectedType: string, actualType: string}>;
  } => {
    const requiredFields = [
      'submissionId',
      'timestamp',
      'status',
      'insured.name',
      'insured.industry.code',
      'insured.industry.description',
      'insured.address.street',
      'insured.address.city',
      'insured.address.state',
      'insured.address.zip',
      'broker.name',
      'coverage.lines',
      'coverage.effectiveDate',
      'coverage.expirationDate'
    ];
    
    const missingRequired = requiredFields.filter(field => {
      // For nested fields, check if they exist in the preview data
      const parts = field.split('.');
      let current = previewData;
      
      for (const part of parts) {
        if (!current || typeof current !== 'object') return true;
        current = current[part];
      }
      
      return current === undefined || current === null;
    });
    
    // For this implementation, we'll keep type checking simple
    const incorrectTypes: Array<{field: string, expectedType: string, actualType: string}> = [];
    
    return {
      valid: missingRequired.length === 0 && incorrectTypes.length === 0,
      missingRequired,
      incorrectTypes
    };
  };
  
  // Auto-map fields based on name similarity
  const autoMapFields = () => {
    if (!sampleData || flattenedApiFields.length === 0) return;
    
    const newMapping = { ...currentMapping };
    
    // Utility to find the best match for a field name
    const findBestMatch = (fieldName: string): string | null => {
      const normalized = fieldName.toLowerCase();
      
      // First look for exact matches
      for (const apiField of flattenedApiFields) {
        const apiFieldName = apiField.split('.').pop()?.toLowerCase() || '';
        if (apiFieldName === normalized) return apiField;
      }
      
      // Then look for contained matches
      for (const apiField of flattenedApiFields) {
        const apiFieldName = apiField.split('.').pop()?.toLowerCase() || '';
        if (apiFieldName.includes(normalized) || normalized.includes(apiFieldName)) return apiField;
      }
      
      return null;
    };
    
    // Helper to map a single field
    const mapField = (appField: string, fieldConfig: any, path = '') => {
      const fieldPath = path ? `${path}.${appField}` : appField;
      
      if (fieldConfig.fields) {
        // Recursively map child fields
        Object.entries(fieldConfig.fields).forEach(([childKey, childConfig]: [string, any]) => {
          mapField(childKey, childConfig, fieldPath);
        });
      } else {
        // Find matching API field
        const match = findBestMatch(appField);
        if (match) {
          // Set the mapping, creating parent objects as needed
          const segments = fieldPath.split('.');
          let current = newMapping;
          
          for (let i = 0; i < segments.length - 1; i++) {
            if (!current[segments[i]]) {
              current[segments[i]] = {};
            }
            current = current[segments[i]];
          }
          
          current[segments[segments.length - 1]] = match;
        }
      }
    };
    
    // Map all app fields
    Object.entries(appFields).forEach(([key, config]: [string, any]) => {
      mapField(key, config);
    });
    
    // Update the mapping
    onMappingChange(newMapping);
    
    // Update preview
    updatePreview(sampleData, newMapping);
  };
  
  // Render app fields recursively
  const renderAppFields = (fields: Record<string, any>, path = '') => {
    return Object.entries(fields).map(([key, config]: [string, any]) => {
      const fieldPath = path ? `${path}.${key}` : key;
      const mappedValue = getMappingForPath(fieldPath);
      const isSelected = selectedAppField === fieldPath;
      
      if (config.fields) {
        return (
          <Box key={fieldPath} sx={{ mb: 2 }}>
            <Typography variant="subtitle1" fontWeight="bold">
              {config.label} {config.required && <span style={{ color: 'red' }}>*</span>}
            </Typography>
            <Box sx={{ pl: 2, borderLeft: '1px solid #ccc' }}>
              {renderAppFields(config.fields, fieldPath)}
            </Box>
          </Box>
        );
      }
      
      return (
        <Card 
          key={fieldPath}
          variant="outlined"
          sx={{
            mb: 1,
            cursor: 'pointer',
            borderColor: isSelected ? 'primary.main' : (mappedValue ? 'success.main' : (config.required ? 'error.light' : 'grey.300')),
            bgcolor: isSelected ? 'rgba(0, 0, 255, 0.05)' : 'background.paper'
          }}
          onClick={() => setSelectedAppField(isSelected ? null : fieldPath)}
        >
          <CardContent sx={{ p: 1, '&:last-child': { pb: 1 } }}>
            <Box display="flex" justifyContent="space-between" alignItems="center">
              <Typography variant="body2">
                {config.label} {config.required && <span style={{ color: 'red' }}>*</span>}
              </Typography>
              {mappedValue && (
                <Chip 
                  label={mappedValue}
                  size="small"
                  color="success"
                  onDelete={() => handleMapField(fieldPath, '')}
                />
              )}
            </Box>
          </CardContent>
        </Card>
      );
    });
  };
  
  // Filter API fields based on search
  const filteredApiFields = flattenedApiFields.filter(field => 
    field.toLowerCase().includes(apiFieldFilter.toLowerCase())
  );

  return (
    <Box>
      <Typography variant="body2" paragraph>
        This visual mapper helps you connect your API data to the dashboard. First, fetch a sample of your API data,
        then map each dashboard field to the corresponding API field by clicking them.
      </Typography>
      
      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 2, mb: 3 }}>
        <Button 
          variant="contained" 
          color="primary" 
          onClick={fetchSampleData} 
          disabled={loading}
          startIcon={loading ? <CircularProgress size={20} /> : null}
        >
          {loading ? 'Fetching...' : 'Fetch Sample Data'}
        </Button>
        
        {sampleData && (
          <Button
            variant="outlined"
            color="secondary"
            onClick={autoMapFields}
          >
            Auto-Map Fields
          </Button>
        )}
        
        <Tooltip title="How to use the mapper">
          <IconButton 
            color="info" 
            onClick={() => setShowTutorial(!showTutorial)}
            sx={{ ml: 'auto' }}
          >
            <HelpOutlineIcon />
          </IconButton>
        </Tooltip>
      </Box>
      
      {showTutorial && (
        <Alert severity="info" sx={{ mb: 3 }} onClose={() => setShowTutorial(false)}>
          <Typography variant="subtitle2">How to use the Visual Mapper:</Typography>
          <ol>
            <li>Ensure you've configured your API endpoint in the Settings page</li>
            <li>Click "Fetch Sample Data" to get data from your API</li>
            <li>Click a dashboard field on the left side to select it</li>
            <li>Click a matching API field on the right side to create a mapping</li>
            <li>Required fields are marked with a red asterisk (*)</li>
            <li>Mapped fields will show a green indicator</li>
            <li>Click "Auto-Map Fields" to automatically find potential matches</li>
          </ol>
        </Alert>
      )}
      
      {error && (
        <Alert severity="error" sx={{ mb: 3 }}>{error}</Alert>
      )}
      
      {sampleData && (
        <Box>
          <Paper sx={{ p: 2, mb: 3 }}>
            <Typography variant="subtitle1" gutterBottom>Sample API Response:</Typography>
            <Box 
              component="pre" 
              sx={{ 
                p: 2, 
                bgcolor: 'rgba(0, 0, 0, 0.04)', 
                borderRadius: 1, 
                maxHeight: '200px', 
                overflow: 'auto',
                fontSize: '0.875rem'
              }}
            >
              {JSON.stringify(sampleData, null, 2)}
            </Box>
          </Paper>
          
          <Box display="flex" gap={2} flexDirection={{ xs: 'column', md: 'row' }}>
            {/* App Fields (Left Side) */}
            <Box width={{ xs: '100%', md: '45%' }}>
              <Typography variant="subtitle1" gutterBottom fontWeight="bold">
                Dashboard Fields
              </Typography>
              <Typography variant="caption" display="block" mb={2}>
                Click on a field to map it with an API field
              </Typography>
              
              <Box sx={{ maxHeight: '500px', overflow: 'auto', pr: 1 }}>
                {renderAppFields(appFields)}
              </Box>
            </Box>
            
            <Divider orientation="vertical" flexItem sx={{ display: { xs: 'none', md: 'block' } }} />
            <Divider sx={{ display: { xs: 'block', md: 'none' }, my: 2 }} />
            
            {/* API Fields (Right Side) */}
            <Box width={{ xs: '100%', md: '45%' }}>
              <Typography variant="subtitle1" gutterBottom fontWeight="bold">
                API Fields
              </Typography>
              
              <Box sx={{ display: 'flex', mb: 2 }}>
                <TextField
                  fullWidth
                  size="small"
                  placeholder="Search API fields..."
                  value={apiFieldFilter}
                  onChange={(e) => setApiFieldFilter(e.target.value)}
                  InputProps={{
                    startAdornment: <SearchIcon color="action" sx={{ mr: 1 }} />
                  }}
                />
                <Tooltip title="Clear search">
                  <IconButton 
                    size="small" 
                    sx={{ ml: 1 }}
                    onClick={() => setApiFieldFilter('')}
                    disabled={!apiFieldFilter}
                  >
                    <RefreshIcon fontSize="small" />
                  </IconButton>
                </Tooltip>
              </Box>
              
              {selectedAppField ? (
                <Alert severity="info" sx={{ mb: 2 }}>
                  Select an API field to map to: <strong>{selectedAppField}</strong>
                </Alert>
              ) : (
                <Typography variant="caption" display="block" mb={2}>
                  Click on an API field after selecting a dashboard field
                </Typography>
              )}
              
              <Box sx={{ maxHeight: '500px', overflow: 'auto' }}>
                {filteredApiFields.map(field => (
                  <Card 
                    key={field}
                    variant="outlined"
                    sx={{
                      mb: 1,
                      cursor: selectedAppField ? 'pointer' : 'default',
                      '&:hover': {
                        bgcolor: selectedAppField ? 'action.hover' : 'background.paper'
                      }
                    }}
                    onClick={() => {
                      if (selectedAppField) {
                        handleMapField(selectedAppField, field);
                      }
                    }}
                  >
                    <CardContent sx={{ p: 1, '&:last-child': { pb: 1 } }}>
                      <Typography variant="body2" fontFamily="monospace">
                        {field}
                      </Typography>
                      <Typography variant="caption" color="text.secondary">
                        Value: {
                          JSON.stringify(getValueFromPath(sampleData, field)).slice(0, 30) + 
                          (JSON.stringify(getValueFromPath(sampleData, field)).length > 30 ? '...' : '')
                        }
                      </Typography>
                    </CardContent>
                  </Card>
                ))}
                
                {filteredApiFields.length === 0 && (
                  <Typography variant="body2" color="text.secondary" textAlign="center" py={4}>
                    No matching API fields found
                  </Typography>
                )}
              </Box>
            </Box>
          </Box>
          
          {/* Preview Section */}
          <Paper sx={{ p: 2, mt: 3 }}>
            <Typography variant="subtitle1" gutterBottom>Mapped Data Preview:</Typography>
            <Box 
              component="pre" 
              sx={{ 
                p: 2, 
                bgcolor: 'rgba(0, 0, 0, 0.04)', 
                borderRadius: 1, 
                maxHeight: '200px', 
                overflow: 'auto',
                fontSize: '0.875rem'
              }}
            >
              {JSON.stringify(previewData, null, 2)}
            </Box>
          </Paper>
        </Box>
      )}
    </Box>
  );
};

export default VisualFieldMapper;